<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>8x8 消消乐 - 拖拽版</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #f8fafc;
      font-family: sans-serif;
      user-select: none;
    }
    h1 { margin: 10px; }
    #score { margin: 10px; font-size: 18px; }
    #board {
      display: grid;
      grid-template-columns: repeat(8, 50px);
      grid-template-rows: repeat(8, 50px);
      gap: 4px;
      margin-top: 10px;
      touch-action: none; /* 禁止默认滚动，保证手势准确 */
    }
    .cell {
      width: 50px;
      height: 50px;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s;
    }
    .cell.selected {
      outline: 3px solid #333;
      transform: scale(1.1);
    }
    .red    { background: #ef4444; }
    .orange { background: #f97316; }
    .yellow { background: #eab308; }
    .green  { background: #22c55e; }
    .blue   { background: #3b82f6; }
    .purple { background: #a855f7; }
  </style>
</head>
<body>
  <h1>8x8 消消乐</h1>
  <div id="score">分数: 0</div>
  <div id="board"></div>

  <script>
    const rows = 8, cols = 8;
    const colors = ["red","orange","yellow","green","blue","purple"];
    let board = [];
    let selected = null;
    let score = 0;
    let touchStart = null;

    const boardEl = document.getElementById("board");
    const scoreEl = document.getElementById("score");

    function randColor() {
      return colors[Math.floor(Math.random() * colors.length)];
    }

    function initBoard() {
      board = [];
      for (let r=0; r<rows; r++) {
        let row = [];
        for (let c=0; c<cols; c++) {
          row.push(randColor());
        }
        board.push(row);
      }
    }

    function renderBoard() {
      boardEl.innerHTML = "";
      for (let r=0; r<rows; r++) {
        for (let c=0; c<cols; c++) {
          const cell = document.createElement("div");
          cell.className = "cell " + board[r][c];
          cell.dataset.r = r;
          cell.dataset.c = c;
          if (selected && selected.r === r && selected.c === c) {
            cell.classList.add("selected");
          }
          cell.onclick = () => handleClick(r,c);

          // 移动端触摸支持
          cell.addEventListener("touchstart", (e)=>{
            e.preventDefault();
            touchStart = {r,c, x:e.touches[0].clientX, y:e.touches[0].clientY};
          });
          cell.addEventListener("touchend", (e)=>{
            if (!touchStart) return;
            const dx = e.changedTouches[0].clientX - touchStart.x;
            const dy = e.changedTouches[0].clientY - touchStart.y;
            let target = null;
            if (Math.abs(dx) > Math.abs(dy)) {
              if (dx > 20 && touchStart.c < cols-1) target = {r:touchStart.r, c:touchStart.c+1};
              else if (dx < -20 && touchStart.c > 0) target = {r:touchStart.r, c:touchStart.c-1};
            } else {
              if (dy > 20 && touchStart.r < rows-1) target = {r:touchStart.r+1, c:touchStart.c};
              else if (dy < -20 && touchStart.r > 0) target = {r:touchStart.r-1, c:touchStart.c};
            }
            if (target) handleSwap(touchStart, target);
            touchStart = null;
          });

          boardEl.appendChild(cell);
        }
      }
    }

    function isAdjacent(a, b) {
      return (Math.abs(a.r - b.r) + Math.abs(a.c - b.c)) === 1;
    }

    function swap(a, b) {
      const tmp = board[a.r][a.c];
      board[a.r][a.c] = board[b.r][b.c];
      board[b.r][b.c] = tmp;
    }

    function findMatches() {
      const marks = Array.from({length: rows}, ()=>Array(cols).fill(false));
      // 横向
      for (let r=0; r<rows; r++) {
        let runColor = board[r][0], runStart = 0;
        for (let c=1; c<=cols; c++) {
          const cur = c<cols ? board[r][c] : null;
          if (cur === runColor) continue;
          const runLen = c - runStart;
          if (runColor && runLen >= 3) {
            for (let k=runStart; k<c; k++) marks[r][k] = true;
          }
          runColor = cur;
          runStart = c;
        }
      }
      // 纵向
      for (let c=0; c<cols; c++) {
        let runColor = board[0][c], runStart = 0;
        for (let r=1; r<=rows; r++) {
          const cur = r<rows ? board[r][c] : null;
          if (cur === runColor) continue;
          const runLen = r - runStart;
          if (runColor && runLen >= 3) {
            for (let k=runStart; k<r; k++) marks[k][c] = true;
          }
          runColor = cur;
          runStart = r;
        }
      }
      return marks;
    }

    function applyMatches(marks) {
      let cleared = 0;
      for (let r=0; r<rows; r++) {
        for (let c=0; c<cols; c++) {
          if (marks[r][c]) {
            board[r][c] = null;
            cleared++;
          }
        }
      }
      if (cleared > 0) score += cleared * 10;
      return cleared;
    }

    function collapseBoard() {
      for (let c=0; c<cols; c++) {
        let col = [];
        for (let r=rows-1; r>=0; r--) {
          if (board[r][c]) col.push(board[r][c]);
        }
        while (col.length < rows) col.push(randColor());
        for (let r=rows-1,i=0; r>=0; r--,i++) {
          board[r][c] = col[i];
        }
      }
    }

    async function processMatches() {
      while (true) {
        const marks = findMatches();
        const cleared = applyMatches(marks);
        if (cleared === 0) break;
        scoreEl.textContent = "分数: " + score;
        renderBoard();
        await new Promise(res=>setTimeout(res,300));
        collapseBoard();
        renderBoard();
        await new Promise(res=>setTimeout(res,200));
      }
    }

    async function handleClick(r,c) {
      if (!selected) {
        selected = {r,c};
      } else {
        const second = {r,c};
        if (isAdjacent(selected, second)) {
          await handleSwap(selected, second);
        }
        selected = null;
      }
      renderBoard();
    }

    async function handleSwap(a, b) {
      swap(a, b);
      renderBoard();
      await processMatches();
    }

    // 初始化
    initBoard();
    renderBoard();
    processMatches();
  </script>
</body>
</html>
